//4.1.Прогрессия(6)
//Король Камбузии с детства боится несчастливых арифметических прогрессий с разностью 13. Однажды ему представили список расходов 
// на нужды подданных, состоящий из N чисел.Король потребовал оставить только такую начальную часть списка, в которой не скрывается
//  несчастливая арифметическая прогрессия.Либеральная общественность, считаясь с мнением короля, настаивает, тем не менее, на сохранении
//  как можно большей части списка.Найти максимальное значение K такое, что из первых K чисел списка невозможно выделить M чисел, следующих
//  в порядке их нахождения в списке и образующих последовательные члены несчастливой арифметической прогрессии.Выдать члены первой обнаруженной несчастливой прогрессии.
//Ввод из файла INPUT.TXT.Первая строка содержит два целых положительных числа N и M, разделенных пробелом : N – количество чисел в списке, а M – недопустимое число
//  членов прогрессии.Вторая строка содержит список расходов в виде целых положительных чисел.
//Ограничения : 2 ≤ N, M ≤ 5000, 1 ≤ Xi ≤ 65000, время 1 с.
//Вывод в файл OUTPUT.TXT.В первой строке выводится единственное число K - максимальное количество начальных чисел списка, не содержащих в качестве подсписка 
// M последовательных членов несчастливой арифметической прогрессии.Во второй строке выводятся через пробел члены первой обнаруженной несчастливой прогрессии.
// Если ее не обнаружено, вывести No.
//Пример
//Ввод
//9 3
//5 9 3 22 16 19 35 7 29
//Вывод
//6
//9 22 35
// Выполнил: Таныгин Вадим ПС-23
//Среда разработки: Visual Studio 2022
#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <iterator>

using namespace std;

int main() {
	ifstream fin("input.txt");
	ofstream fout("output.txt");
	int n, m;
	fin >> n >> m;

	vector < pair<int, int>> a(n);
	for (int i = 0; i < n; i++) {
		fin >> a[i].first;
		a[i].second = i;
	}

	sort(a.begin(), a.end());

	int max_len = 0;
	vector<int> result;
	int k = -1;
	for (int i = 0; i < n; i++) {
		vector<int> temp;
		temp.push_back(a[i].first);
		int j = i + 1;
		while (j < n) {
			if (a[j].first - temp.back() == 13) {
				temp.push_back(a[j].first);
				if (temp.size() == m) {
					max_len = temp.size();
					result = temp;
					k = j;
					break;
				}
				else if (temp.size() > m) {
					break;
				}
				j++;
			}
			else if (a[j].first - temp.back() > 13) {
				break;
			}
			else {
				j++;
			}
		}
	}

	if (max_len == 0) {
		fout << "No" << endl;
	}
	else if (max_len > m) {
		fout << "No" << endl;
	}
	else {
		int index = -1;
		for (int i = 0; i < n; i++) {
			if (a[i].first == result.back()) {
				index = a[i].second;
				break;
			}
		}

		if (index != -1) {
			fout << index << endl;
			copy(result.begin(), result.end(), ostream_iterator<int>(fout, " "));
			fout << endl;
		}
	}

	return 0;
}



